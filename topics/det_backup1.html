<!DOCTYPE html>
<html>
<head>

<title>行列式专题</title>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="mystyle.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
window.MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
<div class="sidebar-container bg-primary">
  
  <div class="sidebar-logo bg-primary">
    <a class="navbar-brand sidebar-top-logo" href="../../index.html">oqnx0902.com</a>
  </div>

  <ul class="sidebar-navigation">
    <li class="header">行列式</li>
    
    <li>
      <a href="#det_def">
        <i class="fa fa-home" aria-hidden="true"></i> 概述
      </a>
    </li>
    
    <li>
      <a href="#det_prop">
        <i class="fa fa-tachometer" aria-hidden="true"></i> 基本性质
      </a>
    </li>

    <li>
      <a href="#det_fm">
        <i class="fa fa-tachometer" aria-hidden="true"></i> 公式推导
      </a>
    </li>

    <li>
      <a href="#det_app">
        <i class="fa fa-tachometer" aria-hidden="true"></i> 应用
      </a>
    </li>

    <li>
      <a href="#det_ext">
        <i class="fa fa-tachometer" aria-hidden="true"></i> 拓展
      </a>
    </li>  

    <li>
      <a href="#det_ref">
        <i class="fa fa-tachometer" aria-hidden="true"></i> 参考资料
      </a>
    </li>    

  </ul>

</div>

<div class="content-container">

  <div class="container-fluid">
    <!-- Main component -->
      <h3 id="det_def">概述</h3>
      <hr>
      <p>
        盛夏的午后，阳光透过窗户照亮了黑板的一角。五年级的教室很安静，只有写字的沙沙声和偶尔铅笔或者直尺掉在地上的声音。
      </p>
      <p>
        这只是一场普通的数学随堂测验，但他却异常紧张。因为有同学议论，说他是因为家长给班主任送了礼才当上数学课代表和宣传委员的。之前的数学课代<abbr title="James Joseph Sylvester" class="text-info">希尔维斯特</abbr>同学不仅成绩比他好，而且上一期的黑板报也办的比他更漂亮，他字写得那么难看，凭什么还能当宣传委员？更让他忐忑不安的是，同学议论他不称职这件事，是放学后，班主任把他叫到办公室悄悄告诉他的。他知道老师是为了鞭策他，当然不会怨老师；他知道同学们其实说的也有道理，所以也不能去反驳。只能以后，不，包括这一次的每次测验和考试，都要比<span class="text-info" >希尔维斯特</span>考得好了。"呵，<span class="text-info">希尔维斯特</span>，什么鬼名字。"他心里想。
      </p>
      <p>
        很快，来到了最后一道应用题前面。他根据应用题的条件，设了两个未知数，列了两个方程，如下:
      </p>
      <p>
        \begin{align*} 
        ax + by &=  A \\ 
        cx + dy &=  B
        \end{align*}
      </p>
      <p>   
        其中 \(a\), \(b\), \(c\), \(d\) 以及 \(A\), \(B\) 是常数, \(x\), \(y\) 是待求的未知数。
      </p>
      <p>
        他将第一个方程左右两边乘以了 \(c\), 然后将第二个方程左右两边乘以了 \(a\)。</p>
      <p>
        两个方程就变成了:
      </p>
      <p>
        \begin{align*} 
        cax + cby &=  cA \\ 
        acx + ady &=  aB
        \end{align*}
      </p>
      <p>
        此时两个方程中未知数 \(x\) 的系数是一致的，都是 \(ac\)。 自然地，用第二个方程减去第一个方程，就可以消去 \(x\), 得到: 
      </p>
      <p> 
        \begin{align*}  
        (ad-bc)y =  aB-cA
        \end{align*}
      </p> 
      <p>
        有了这个式子，就能解出 \(y\), 然后将得到的 \(y\) 带入最初两个方程中的任意一个，问题就解决了。
      </p>
      <p>
        于是他照做了，但当用第二个方程减去第一个方程消去 \(x\) 的时候，他最担心的事情还是发生了。他发现，消去 \(x\) 的同时， \(y\) 也没了。也就是说方程
      </p>
      <p> 
        \begin{align*}  
        (ad-bc)y =  aB-cA
        \end{align*}
      </p> 
      <p>
        中 \(y\) 的系数 <span class="text-warning">\(ad-bc=0\) </span>。危险！这意味着他虽然列了两个方程，但实质上是同一回事，也意味着应用题给的条件他没有全部用上。于是连忙重新审题并检查自己列的方程，看看是把笼子里面的鸡忘记算了还是把兔子算成两只脚了。
      </p> 
      <p> 
        终于找到了出错的地方，重新列了方程，但距离考试结束已经不足三分钟了。他只能匆忙地算出了一个答案，来不及检查，就交了卷。
      </p>
      <p>
        这一晚，睡得不踏实。
      </p>
      <p>
        第二天下午，卷子发下来了，100分，和<span class="text-info">希尔维斯特</span>并列全班第一。他舒了口气，好歹这次没有丢面子。他盯着昨天的方程:
      </p>
      <p>
        \begin{align*} 
        ax + by &=  A \\ 
        cx + dy &=  B
        \end{align*}
      </p>
      <p>
        发觉其实类似的二元一次方程组，是否能算个答案出来，好像只和两个方程未知数的系数 \(a\), \(b\), \(c\), \(d\) 相关，只要 \(ad-bc=0\) ，这题目就不用往下做了。如果暂时忽略掉未知数，单独把这四个系数按照原方程组的位置摆出来: 
      </p>
      <p>
        \begin{vmatrix}
        a & b \\
        c & d 
        \end{vmatrix}
      </p>
      <p>
        那么看起来更加直观，\(ad-bc\) 就可以理解为两组对角线上的数字相乘然后再相减了，即:
      </p>
      <p>
        \begin{equation*}
        \begin{vmatrix}
        a & b \\
        c & d \\
        \end{vmatrix} = ad - bc
        \end{equation*}
      </p>
      <p>
      	这样记忆起来也更加方便。他决定给这玩意起个炫酷的名字，干脆先来个英文名吧。既然它决定了题目还需不需要继续做下去，而决定的 英文是<span class="text-primary">determine</span>，那就叫它为<span class="text-primary">determinant</span> 吧，简称<span class="text-primary">det</span>。“<span class="text-primary">Determinant</span>,  嗯，真是个好听又暗藏玄机的名字，”他开心地想：“还得再来个更加玄妙的中文名。”
      </p>
      <p>
        “直接叫做决定数?毕竟本质上就是一个决定题目需不需要继续做下去的数字，但是这样太过直白，大家一眼就看懂了，没有神秘感。不行，得起一个看起来就很深奥的名字。”他又看了看这个式子：   
      </p>
      <p>
        \begin{vmatrix}
        a & b \\
        c & d 
        \end{vmatrix}
      </p>
      <p>
        “有行有列，那就叫它<span class="text-primary">行列式</span>吧。行列式行列式，听起来像个式子，但其实是个数字。”他心中乐道。
      </p>
      <p>
      	于是<span class="text-primary">行列式</span>诞生了，但事情并未结束。因为六年级来了，三元一次方程出现了：
      </p>
      <p>
        \begin{align*} 
        a_{11}x + a_{12}y + a_{13}z &=  A \\ 
        b_{21}x + b_{22}y + b_{23}z &=  B \\
        c_{31}x + c_{32}y + c_{33}z &=  C 
        \end{align*}
      </p>
      <p>
      	其中 \(x\), \(y\), \(z\) 是未知数。
      </p>
      <p>
        那么像这样的三元一次方程有没有对应的行列式呢？他按照之前的样子，先丢掉了三元一次方程的未知数，将未知数的系数排列如下:
      </p>
      <p>
        \begin{vmatrix}
        a_{11} & a_{12} & a_{13}\\
        b_{21} & b_{22} & b_{23}\\
        c_{31} & c_{32} & c_{33}
        \end{vmatrix}
      </p>
      <p>
         然后脑海里开始回放三元一次方程组的消元过程：
      </p>
      <p>
      	先利用第一个方程，消去后面两个方程当中的 \(x\)。 也就是后面两个方程左右两边同时乘上 \(a_{11}\), 然后分别减去第一个方程在左右两边同时乘以 \(b_{21}\) 和 \(c_{31}\) 的结果。 那么第二个方程 \(x\) 的系数就成了 \(b_{21}a_{11}-a_{11}b_{21}=0\), 第三个方程类似。 
      </p>
      <p>
      	为了方便观察，对第一个方程的操作都在脑海里进行，只记录后两个方程操作后的结果，那么原来的系数排列，在第一次消元后就变成了：
      </p>
      <p>
        \begin{vmatrix}
        a_{11} & a_{12}                    & a_{13}\\
        0      & b_{22}a_{11}-a_{12}b_{21} & b_{23}a_{11}-a_{13}b_{21}\\
        0      & c_{32}a_{11}-a_{12}c_{31} & c_{33}a_{11}-a_{13}c_{11}
        \end{vmatrix}
      </p>
      <p>
        现在再利用第二个方程，用相同的方法，消去第三个方程中的 \(y\)。也就是第三个方程左右两边同时乘以现在第二个方程中 \(y\) 的系数，即上面系数排列的第二行第二列： \(b_{22}a_{11}-a_{12}b_{21}\)。 然后再减去第二个方程左右两边同时乘以第三个方程中 \(y\) 的系数，即上面系数排列的第三行第二列： \(c_{32}a_{11}-a_{12}c_{31}\)。那么第三个方程中的 \(y\) 的系数就变为 \(0\) 了。同样的，记录的时候没必要记录第二个方程的变化，仅记录第三个方程的变化即可，那么上面的系数排列变为:
      </p>
      <p>
        \begin{vmatrix}
        a_{11} & a_{12}                    & a_{13}\\
        0      & b_{22}a_{11}-a_{12}b_{21} & b_{23}a_{11}-a_{13}b_{21}\\
        0      & 0                         & (c_{33}a_{11}-a_{13}c_{31})(b_{22}a_{11}-a_{12}b_{21}) - (  b_{23}a_{11}-a_{13}b_{21})(c_{32}a_{11}-a_{12}c_{31})
        \end{vmatrix}
      </p>
      <p>
      	得到了第三个方程消掉 \(x\), \(y\) 后，\(z\) 的系数: 
      </p>
      <p>
        \((c_{33}a_{11}-a_{13}c_{31})(b_{22}a_{11}-a_{12}b_{21}) - (b_{23}a_{11}-a_{13}b_{21})(c_{32}a_{11}-a_{12}c_{31})\)
      </p>
      <p>
        好大一串式子，别无选择，展开化简吧。化简后这个式子成了:
      </p>
      <p>
        \(a_{11}[a_{11}(c_{33}b_{22}-b_{23}c_{32})-a_{12}(b_{21}c_{33}-c_{31}b_{23})+a_{13}(b_{21}c_{32}-c_{31}b_{22})]\)
      </p>
      <p>
        也就是说上面这个式子是不是等于 \(0\)，成了关键。如果等于 \(0\)，这题也做不下去了，意味着上一步的两个方程，消去 \(y\) 的同时 \(z\) 也没了。不等于 \(0\)，代表着上式中括号里面那一长串式子不能为 \(0\)。
      </p>
      <p>
        当他将中括号中的式子写下来的时候，惊喜出现了:
      </p>
      <p>
        \(a_{11}(c_{33}b_{22}-b_{23}c_{32})-a_{12}(b_{21}c_{33}-c_{31}b_{23})+a_{13}(b_{21}c_{32}-c_{31}b_{22})\)
      </p>
      <p>
        因为按照之前给二元一次方程组<span class="text-primary">行列式</span>的定义，即：
      </p>
      <p>
        \begin{equation*}
        \begin{vmatrix}
        a & b \\
        c & d \\
        \end{vmatrix} = ad - bc
        \end{equation*}
      </p>
      <p>
        那么就有：
      </p>
      <p>
        \begin{equation*}
        c_{33}b_{22}-b_{23}c_{32}
        =
        \begin{vmatrix}
        b_{22} & b_{23} \\
        c_{32} & c_{33} \\
        \end{vmatrix}
        \;\;\;
        b_{21}c_{33}-c_{31}b_{22}
        =
        \begin{vmatrix}
        b_{21} & b_{23} \\
        c_{31} & c_{33} \\
        \end{vmatrix}
        \;\;\;
        b_{21}c_{32}-c_{31}b_{22}
        =
        \begin{vmatrix}
        b_{21} & b_{22} \\
        c_{31} & c_{32} \\
        \end{vmatrix}

        \end{equation*}
      </p>
      <p>
        拼起来就是: 
      </p>
      <p>
        \begin{equation*} 
          a_{11}(c_{33}b_{22}-b_{23}c_{32})-a_{12}(b_{21}c_{33}-c_{31}b_{23})+a_{13}(b_{21}c_{32}-c_{31}b_{22})
          = 
        \end{equation*}

        \begin{equation*} 
           a_{11}\begin{vmatrix}
            b_{22} & b_{23} \\
            c_{32} & c_{33} \\
           \end{vmatrix}
           -
           a_{12}\begin{vmatrix}
            b_{21} & b_{23} \\
            c_{31} & c_{33} \\
           \end{vmatrix}
           +
           a_{13}\begin{vmatrix}
            b_{21} & b_{22} \\
            c_{31} & c_{32} \\
           \end{vmatrix}                      
        \end{equation*}
      </p>
      <p>
        也就是说决定着三元一次方程组是不是需要解下去的这个数，即刚才中括号里面的式子，可以分解成 \(3\) 个二阶的行列式，各自乘上一个常数。
      </p>
      <p>
        "这就是决定着三元一次方程组生死的<span class="text-primary">determinant</span>，也就是<span class="text-primary">行列式</span>了！"于是他将行列式殊荣赋予了这一串式子，怀着激动的心情，颤颤巍巍地写下：
      </p>
      <p>
        \begin{equation*} 
        \begin{vmatrix}
        a_{11} & a_{12} & a_{13}\\
        b_{21} & b_{22} & b_{23}\\
        c_{31} & c_{32} & c_{33}
        \end{vmatrix}   
        =
        a_{11}\begin{vmatrix}
         b_{22} & b_{23} \\
         c_{32} & c_{33} \\
        \end{vmatrix}
        -
        a_{12}\begin{vmatrix}
         b_{21} & b_{23} \\
         c_{31} & c_{33} \\
        \end{vmatrix}
        +
        a_{13}\begin{vmatrix}
         b_{21} & b_{22} \\
         c_{31} & c_{32} \\
        \end{vmatrix}   
        \end{equation*} 
      </p>
      <p>
        如果说五年级的盛夏见证了<span class="text-primary">行列式</span>的诞生，那么六年级的初春则见证了<span class="text-primary">行列式</span>的生长。
      </p>
      <p>
      	他再次回望上面的公式，在这一历史时刻，细细品味着，生怕错过了什么。 他忽然观察到：<br>
      	等式右边的第一项，是三阶行列式的第一行第一列的数，即 \(a_{11}\), 乘上一个二阶的行列式。而这个二阶行列式又正好是三阶行列去掉第一行和第一列后剩下的二阶行列式。<br>
      	等式右边的第二项，是三阶行列式的第一行第二列的数，即 \(a_{12}\), 乘上一个二阶的行列式。而这个二阶行列式又正好是三阶行列去掉第一行和第二列后剩下的二阶行列式。<br>
      	等式右边的第三项，是三阶行列式的第一行第三列的数，即 \(a_{13}\), 乘上一个二阶的行列式。而这个二阶行列式又正好是三阶行列去掉第一行和第三列后剩下的二阶行列式。<br>
      </p>
      <p>
      	这个规律太美妙了。
      	也就是说可以将一个三阶行列式沿着第一行的元素，逐个展开，唯一需要注意的是展开后的三项，符号依次是 \(+\), \(-\), \(+\)。
      </p>
      <p>
      	那么四阶行列式是不是有类似的规律呢？比如也能用来对四元一次方程组是否可以求解的判定功能？比如也能沿着第一行的元素依次展开，并且按照之前的规律，四阶的行列式应该是可以展开成 \(4\) 个三阶的行列式。
      </p>
      <p>
      	现在的他太兴奋了，无暇思考四阶的事情。他连忙向老师和同学们解释着自己的发现，语气中带着几分得意和几分焦急。如他所料，瞬间，<span class="text-primary">行列式</span>这三个字，引爆全校，获得了师生一致肯定。校长甚至表示要把这个概念推广到隔壁学校。那段时间，他可谓声名鹊起，风头一时无二，虚荣心得到了极大满足。似乎关于他和<span class="text-info" >希尔维斯特</span>谁更应该当数学课代表的争论已经尘埃落定了。似乎唯一的争议就只剩下“宣传委员得办漂亮的黑板报”这个命题正确与否上了。
      </p>
      <p>
        可惜，好景不长。毕竟未成年的丛林中，危机四伏。
      </p>
      <p>
        随着校长的大力推广，越来越多的外校同学开始学习<span class="text-primary">行列式</span>这个概念。有学渣哭爹喊娘，就有学霸崭露峥嵘。就在他春风得意马蹄疾，每天不做数学题，专注于练字、绘画以及办出史上最美黑板报从而把<span class="text-info" >希尔维斯特</span>稳稳压住一头的时候，有消息传来了。
      </p>
      <p>
        西联附小的四年级学生<abbr title="Pierre-Simon Laplace" class="text-info">拉普拉斯</abbr>，证明了四阶行列式确实可以和三阶行列式一样，沿着第一行的元素逐个展开。并且将这个规律推广到了 \(n\) 阶，即 \(n\) 阶行列式可以沿着第一行的元素逐个分解成 \(n\) 个 \(n-1\) 阶的行列式。      
      </p>
      <p>
        更令人惊讶的是，<span class="text-info">拉普拉斯</span>证明了这种分解，并不局限于第一行，而是适用于任意一行，只需调整 \(+\), \(-\) 号出现的顺序即可。具体说来，如果沿着奇数行分解，那么展开后各项的符号依次是 \(+\), \(-\), \(+\), \(-\) ......； 如果是沿着偶数行分解，那么展开后各项的符号依次是 \(-\), \(+\), \(-\), \(-\) ......       
      </p>
      <p>
        更让人震惊的是<span class="text-info">拉普拉斯</span>还证明了，上述针对行的操作，对列同样成立。就是说沿着某一列去分解行列式，也完全行得通。
      </p>
      <p>
        瞬间，群声鼎沸；校园内外，议论纷纷。连校长都质问他，“为什么这段时间不将精力放在行列式的研究上，率先提出些重要结论。现在让一个外校生抢了风头，你让我以后怎么出去搞宣传？”
      </p>
      <p>
        虽说<span class="text-info">拉普拉斯</span>的推广与证明，是建立在他的发现之上的，所以也可以算是对他早期工作的肯定。但这种划时代似的重大推广，没能从他这个行列式创始人口里说出，还是让他一时有些脸红。但如果说这件事是让他有些脸红的话，那接下来发生的一件事情就是让他有点坐不住了。
      </p>
      <p>
        那是上午第二三节课的课间，刚做完眼保健操，大家还在各自座位上休息的时候，一个高瘦的身影出现在了教室门口。“啊，<abbr title="Carl Friedrich Gauss" class="text-info">高斯</abbr>？”同学中有人喊道。<span class="text-info">高斯</span>，西联附中顶级学霸，堪称学神。七岁的时候就在奥林匹克数学竞赛中一鸣惊人，击败众多高中生，成为了最年轻的奥数金牌拥有着。之后又凭借着在几何、代数、天文等领域的突出贡献，被破格提前录取到全国最好的大学<i class="text-muted">世一大</i> 的数学专业。但<span class="text-info">高斯</span>拒绝入学，坚持要读完高中。理由是年纪太小，暂时不想离家太远。在热爱数学的小学生眼里，<span class="text-info">高斯</span>就是神一般的存在。站在教室门口的<span class="text-info">高斯</span>，摘下了自己的帽子，摸着头发，逐个环视的教室里的同学。终于，眼神停留在了他身上。“同学，请你出来一下。”<span class="text-info">高斯</span>轻声说道。教室里瞬间鸦雀无声，几十双眼睛望向了他。于是在全班同学的注视下，他走出了教室；在全体师生以及门卫的注视下，他走出了校门。跟着<span class="text-info">高斯</span>走进了学校对面的瑞幸咖啡。
      </p>
      <p>
        事后总有不了解当时情况的人对这一段历史持怀疑态度，他们质疑一个高中生凭什么能在众目睽睽下大摇大摆地走进小学课堂并带走小学生。但他们忘了这个高中生叫<span class="text-info">高斯</span>。凭借当时<span class="text-info">高斯</span>的地位，就算是走进校长室带走校长，那也是可能的。
      </p>
      <p>
        咖啡店里，<span class="text-info">高斯</span>和他面对面地坐在一个安静的角落。正当他准备说几句客套话来掩饰自己初次面对大佬的紧张心情时，<span class="text-info">高斯</span>开口了。和历史上的大神一样，<span class="text-info">高斯</span>很直接：“我觉得你提出的行列式，实际用途不大，”高斯接着说道：“ 西联各级学校都在研究这个，我觉得是一种资源浪费。” 他一下子愣住了，有种冬天被一盆冷水从头浇到脚的感觉。可还没来得及开口回应，高斯又说道：“目前根据你和<abbr title="Pierre-Simon Laplace" class="text-info">拉普拉斯</abbr>的结论来看，行列式是逐级定义的，计算一个 \(4\) 阶的行列式，必须先展开成 \(4\) 个 \(3\) 阶的行列式， 而每个 \(3\) 阶的行列式又需要展开成 \(3\) 个 \(2\) 阶的行列式， 一个 \(2\) 阶的行列式计算 \(2\) 次乘法。 所以整个计算过程，忽略掉加减法的话，一个 \(4\) 阶的行列式需要计算 \(4! = 4 * 3 * 2 * 1 = 24\) 次。假设现在面对着一个 \(25\) 阶的行列式，就要计算 \(25!\) 也就是大概 \(1.5 * 10^{25}\) 次乘法。 这是什么概念呢？ 如果一个人一秒钟可以计算一次乘法，那么让 \(10\) 亿人共同计算，需要 \(5\) 亿年才能算出来，你觉得实际吗？ 如果花这么大的代价就是为了判断一个方程组有没有解，那为什么不直接消元，解得出来就有，解不出来就没有呢？你明白我的意思了吗？”
      </p>
      <p>
        他此刻心情平复稍许，也觉得<span class="text-info">高斯</span>说得有点道理了：毕竟现在在航空航天方面，一个 \(25\) 阶的方程组已经算不上什么了。行列式想要应用到科学以及工程实践上，就必须考虑计算量这个问题。于是他看向<span class="text-info">高斯</span>，点了点头。<span class="text-info">高斯</span>此时的语气缓和一点了，继续说道：“现在西联各级学校，甚至有些大学，就因为行列式这个话题很受关注又比较容易出成果，于是大力号召学生研究这个，大搞为了创新而创新，为了成果而拼搏的科研，这是不对的。学生，特别是在学生年代，应该做的事情就是脚踏实地地打好基础，基础知识都不牢固，那科的是什么研呢？从小就养成了什么容易出成果就研究什么的习惯，长大了又怎么能找到自己的兴趣和热爱所在，从而真正静下心来做学问呢？”高斯顿了顿，喝了一口手中还在冒着热气的泡沫拿铁，更加温和地说道：“我不是在对你发脾气，我只是看不惯最近这一股歪风邪气。我相信你肯定是真心喜欢行列式这个东西的。我今天跟你说这些，一是提前通知你，下周的数学联盟代表大会上，我会以西联附中代表的身份叫停这种无意义的科研竞争。第二也是希望你能够在今天之后，想一想，看能否给行列式一个更加友好的定义，或者找到其他更加简便的计算方法，否则行列式这三个字很难在当今的数学体系中占据一席之地。最近你的同班同学<span class="text-info" >希尔维斯特</span>提出了<span class="text-primary">矩阵</span>的概念，我感觉很有意思，你们两个讨论一下，互通有无。我相信如果有一个人能让行列式焕发新生的话，那这个人一定就是你。”说完，<span class="text-info">高斯</span>舔掉了咖啡杯盖上的最后一点泡沫，起身离开了。
      </p>
      <p>
        回到家中，坐立难安。<span class="text-info">高斯</span>的一席话几乎是判了行列式的死刑，可走之前的那句“那个人一定是你”又让他觉得自己被这个世界选中了，仿佛<span class="text-info">高斯</span>在转身离开的同时，将数学的火种留在了咖啡杯里，传给了他。<span class="text-primary">矩阵</span>，又是<span class="text-info" >希尔维斯特</span>，他念叨着。
      </p>
      <p>
      	第二天，六年级的教室里出现了特别的一幕，大家第一眼都不肯相信自己的眼睛：班上两位从来互相看不顺眼的数学天才正在热烈地讨论问题，从表情和动作上来看，其中一位还显得非常谦虚。没错，不就之前还不可一世的他正在虚心的向<span class="text-info" >希尔维斯特</span>请教<span class="text-primary">矩阵</span>的知识。<span class="text-info" >希尔维斯特</span>也显得非常的友好，耐心地解答着他心中每一个疑惑。此后类似交流讨论的场景时常出现在六年级的教室里，甚至连上学放学的路上都能看到他们推着自行车边走路边探讨数学的身影。同学都感慨道：不愧是<span class="text-info">高斯</span>啊，一番简单的攀谈交心，就能让两位数学小天才从形同陌路到形影不离，大神的人格魅力恐怖如斯。
      </p>
      <h3 id="det_prop">基本性质</h3>
      <hr>
      <p>
      	不久，毕业季如约而至。毕业典礼上，在<span class="text-info" >希尔维斯特</span>发表了名为 <cite>矩阵：崭新的未来</cite> 主题演讲后，他作为压轴学生代表，发表了题为 <cite>新世纪的行列式</cite> 的总结报告。在报告中他指出，对于行列式的学习和研究，可以暂时先将行列式的定义放在一旁，将行列式放入更为宏大的<span class="text-primary">矩阵</span>理论框架中，从行列式的基本性质入手, 逐步加深对行列式的理解。
      </p>
      <p>
        设 \(A\) 为 \(n\) 阶方阵，那么 \(A\) 的<span class="text-primary">行列式(Determinant)</span> 记为 \(det(A)\) 或者 \(|A|\).<br>
      	<mark>
      	在<span class="text-primary">矩阵</span>理论框架下，行列式的基本性质非常简单，只有 \(3\) 点：
      </mark>
      </p>
      <p class="text-primary font-weight-bold">
      	1. 单位矩阵 \(I\) 的行列式为 \(1\), 即 \(det(I) = 1\).
      </p>
      <p>
      	用 \(2\), \(3\) 阶单位矩阵为例就是：
        \begin{equation*} 
        \begin{vmatrix}
        1 & 0 \\
        0 & 1 
        \end{vmatrix}   
        =
        1
        \;\;\;\;\;\;
        \begin{vmatrix}
        1 & 0 & 0\\
        0 & 1 & 0\\
        0 & 0 & 1
        \end{vmatrix}   
        =
        1 
        \end{equation*} 
        当然，\(n\) 阶也是一样，都等于 \(1\)。
      </p>
      <p class="text-primary font-weight-bold">
      	2. 交换矩阵的任意两行，行列式变号。
      </p>
       <p>
      	以 \(2\), \(3\) 阶矩阵为例：
      	\begin{equation*} 
        \begin{vmatrix}
        a & b \\
        c & d 
        \end{vmatrix}   
        = -
        \begin{vmatrix}
        c & d \\
        a & b 
        \end{vmatrix}  
        \;\;\;\;\;\;
        \begin{vmatrix}
        a_{11} & a_{12} & a_{13}\\
        b_{21} & b_{22} & b_{23}\\
        c_{31} & c_{32} & c_{33}
        \end{vmatrix}
        = -
        \begin{vmatrix}
        b_{21} & b_{22} & b_{23}\\
        a_{11} & a_{12} & a_{13}\\
        c_{31} & c_{32} & c_{33}
        \end{vmatrix}
        \end{equation*} 
        \(n\) 阶同理。
      </p>
      <p class="text-primary font-weight-bold">
        3. 对任意一行来言，行列式是个线性函数。
      </p>
      <p>
        这里首先要理解，行列式是个函数，输入的是矩阵 \(A\), 输出的是一个数值 \(det(A)\). 就像函数 \(f(x)\) 一样，输入的是 \(x\), 输出 \(f(x)\).
      </p>
      <p>
        再搞清楚什么叫做线性函数，线性函数有两个性质: <br>
        \(1.\;\;f(ax) = af(x)\). <br>
        \(2.\;\;f(x+y) = f(x) + f(y)\) <br>
        这两个性质可以合在一起，写成一个更加紧凑的表达方式:<br>
        \(f(ax + by) = af(x) + bf(y)\)<br>
        想一下最简的一次函数\(f(x) = x\), 就明白了。
      </p>
      <p>
        那么行列式 \(det(A)\)是线性函数，是不是代表着 \(det(aA) = a\;det(A)\) 或者 \(det(A+B) = det(A) + det(B)\) 成立呢？ (\(A\), \(B\) 均为方阵)
      </p>
      <p class="text-danger">
        都不是，一个都不成立！绝大部分情况下 \(det(aA) \neq a\;det(A)\) 而且 \(det(A+B) \neq det(A) + det(B)\).
      </p>
      <p>
        因为行列式的线性是针对单独一行来说的。以 \(2\) 阶行列式为例: <br>
        <mark class="font-italic">1. 对矩阵某一行所有元素乘以一个常数 \(a\), 新矩阵的行列式等于对原矩阵行列式的 \(a\) 倍:</mark>
        \begin{equation*} 
        \begin{vmatrix}
        ax_{11} & ax_{12}  \\
        x_{21} & x_{22}
        \end{vmatrix}   
        = 
        a\begin{vmatrix}
        x_{11} & x_{12}  \\
        x_{21} & x_{22}
        \end{vmatrix}  
        \end{equation*} 
        这个规律对任意一行都成立，但一定要记住是<span class="font-weight-bold">单独一行</span>，而不是矩阵全体元素一起乘以 \(a\). <br>
        <mark class="font-italic">2. 保持矩阵 \(A\) 其余行不变，将第 \(1\) 行中的每个元素分解成两个元素之和，分解出来的元素分别与其余不变行组成新的两个矩阵 \(A1\), \(A2\), 那么 \(det(A) = det(A_1) + det(A_2)\)</mark>。这句话看起来很绕口，但写成公式非常简单，一看就明白：
        \begin{equation*} 
        \begin{vmatrix}
        x_{11} + x_{11}' & x_{12} + x_{12}'  \\
        x_{21}           & x_{22}
        \end{vmatrix}   
        = 
        \begin{vmatrix}
        x_{11} & x_{12}  \\
        x_{21} & x_{22}
        \end{vmatrix}  
        +
        \begin{vmatrix}
        x_{11}' & x_{12}'  \\
        x_{21}  & x_{22}
        \end{vmatrix}   
        \end{equation*} 
        同样，这个规律对于其他任意一行也成立，但一定也是<span class="font-weight-bold">单独一行</span>，而不是把整个矩阵所有元素一起拆开了。
      </p>
      <h3 id="det_app">公式与定理</h3>
      <hr>
      <p>此处添加内容</p>
      <h3 id="det_fm">应用</h3>
      <hr>
      <p>此处添加内容</p>
      <h3 id="det_app">拓展</h3>
      <hr>
      <p>此处添加内容</p>
      <h3 id="det_ref">参考资料</h3>
      <hr>
      <p>此处添加内容</p>      
  </div>
  <footer class="page-footer font-small blue pt-4 fixed-bottom">
  <!-- Copyright -->
  <div class="footer-copyright text-center py-3">© 2020 Copyright:
    <a href="https://oqnx0902.com/"> oqnx0902.com</a>
  </div>
  <!-- Copyright -->
</footer>
</div>

</body>
</html